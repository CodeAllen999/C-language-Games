关于代码，有一个建议：

目前形状是这么表示的：
0,0,1,1,/* ━ */
0,1,0,1,/* ┏ */
0,1,1,0,/* ┓ */
0,1,1,1,/* ┳ */
1,0,0,1,/* ┗ */
1,0,1,0,/* ┛ */
1,0,1,1,/* ┻ */
1,1,0,0,/* ┃ */
1,1,0,1,/* ┣ */
1,1,1,0,/* ┫ */
1,1,1,1,/* ╋ */

一个建议：可以用一个 byte 表示形状的连通性。例如，可以这样获取一个随机的形状：
char shape;
do
{
shape = rand() % 13 + 3;
}while((shape == 4) || (shape == 8));

然后，可以用位操作判断 shape 的各向连通性。例如，
如果 shape & 8 == true，就表示向上是连通的。
shape & 1 == true 就表示右连通。
下和左类似。

收起回复(4) 6楼2013-09-02 21:21删除 |

i92076: 好想法，程序初期为了直观，写好之后完全可以用位操作优化
删除 |  2013-9-2 21:43 回复

i92076: 采用位操作后顺、逆时针的映射变换也不需要搞一个映射表了，把原来‘上下左右’的规定改为‘上左下右’，然后用左、右循环移位就能模拟旋转问题了，真是高啊
删除 |  2013-9-2 22:10 回复

i92076: 回复 i92076 :再把贴图的排列顺序调整一下重新做一张，然后用for循环批量加载各个分块……程序精简n多行……要不是我懒我真就改了